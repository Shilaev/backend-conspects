## Структура программы
Программа Go хранится в **одном или нескольких файлах**, с расширением **.go**.
1) Файл начинается с объявления **package** - указывает частью какого пакета является файл.
2) Затем **import** - импортирует другие пакеты
3) Затем последовательность объявления типов, п еременных, констант, функций уровня пакета в произвольном порядке.

```Go
package main
import "fmt"
const someConst = 9.85
func main(){
    var f = someConst
}
```

## Переменные
Объявление **var** создает переменную определенного типа, назначает ей имя и присваивает начальноее значение.
**Полное объявление переменных**
```Go
var varName type = expression // полное указание
var varName = expression // компилятор сам определит тип
var varName type // создаст переменную с нулевым дефолтным
                  //значением (0, false, nil, "")
var i, j, k int // создаст 3 int с нулевым значением
var i, j, k = true, 2.3, "some" // создаст 3 переменные со
                          //значениями, которые указаны далее.
```
**Краткое объявление переменных**
```Go
name := expression
anim := gif.GIF{...}
t := 0.0
x, y := true, 1
```
Краткое объявление переменных может исопльзоваться для вызова функций.
```Go
f, err := os.Open(name)
```
!!Важно. В данном случае err не пересоздастся, а к ней будет присвоено новое значение
```Go
in, err := os.Open()
out, err := os.Create()
```

## Указатели
Переменная представляет собой небольшой блок памяти, содержащий значение.
Значение **указателя** представляет собой **адрес** переменной. Таким образом, **указатель** - это **местоположение в памяти**, где **хранится значение**. Не любое значение имеет адрес, но его имеет любая переменная. С помощью указателя можно считывать или изменять значение переменной косвенно, не используя ее имя, если оно есть.
```Go
var x int
p := &x // указатель на местоположение в памяти, указывает на значение
// p указывает на x
// p содержит адрес x
print(*p) // Это переменная, которую мы найдем, если перейдем по адресу, который хранится внутри p.
```

## Функция new
Еще один способ создания переменных. **new** создает неименованную переменную типа T, инициализирует ее нулевым значением и возвращает ее адрес.
```Go
p := new(int)
```

## Присваивание кортежу поменять местами
Очень удобно менять местами переменные, без добавления временной переменной.
Данная запись
```Go
tmp := x
x = y
y = tmp % y
```
эквивалентна этой, в короткой записи
```Go
x, y = y, x%y
```

## Объявление типов
Объявление type определяет новый именованный тип, который имеет тот же базовый тип, что и существующий.
```Go
type Celsius float64
const AbsoluteZeroC Celsius = -273.15
```

## Пакеты и файлы
Это аналог модулей и библиотек из других языков.
В Go экспортируются идентификаторы. которые начинаются с прописной буквы.
То есть если написать функцию
```Go
func doThis() {
	fmt.Println("doThis")
}
```
То она не будет доступна вне пакета, а если написать
```Go
func DoThis() {
	fmt.Println("doThis")
}

package.DoThis()
```
То вот она будет доступна

## Строки и байтовые срезы
Для работы со строками есть 4 стандартных пакета:
**strings** - предоставляет множество функций для поиска, замены, сравнения. обрезки. разделения, объединения строк
**bytes** - аналогичные функции, но для работы со срезами
**strconv** - функции для преобразования булевых значений, целых чисел и чисел с плавающей точкой в строковое представление и обратно
**unicode** - функции для классификации рун, IsDigit, IsLetter, IsUpper, IsLower и така далее

Строки можно преобразовывать в байтовые срезы и обратно:
```Go
s := "abc"
b := []byte(s)
s2 := string(b)
```
[]byte(s) - выделит память для нового массива байтов, хранящего копию байтов строки s и дает срез, ссылающийся на весь этот массив.

## Преобразования между строками и числами
делается с помощью пакета **strconv***
```Go
strconv.Itoa //integer to ASCII
x := 123
y := strconv.Itoa(x) // 123
```

Для форматирования числе из другой системы счисления
```Go
strconv.FormatInt(int64(x), 2) // 1111011
```

## Константы
Значение констрант известны компилятору и вычисление гарантированно происходит во время компиляции, а не во время выполнения. 
```Go
const name = "value"

const (
    a = 1
    b     // 1 по умолчанию
    c = 2
    d     // 1 по умлочанию
)
```
Многие вычисления констант могут быть полностью завершены во время компиляции, уменьшая тем самым кол-во работы. необходимой во время выполнения. 

**Генератор констант iota**
**iota** - применяется для создания последовательности связанных значений без их явного указания.
в объявлении const значение iota начинается с нуля и увеличивается на единицу для каждого следующего.
```Go
type Counter int

const (
	x Counter = iota // 0
	y                // 1
	z                // 2
	a                // 3
	b                // 4
	g                // 5
)

const (
	_ = 9 + iota
	x                // 10
	y                // 11
	z                // 12
)
```


**Нетипизированные константы**
Константа может быть не привязана к определенному типу.
Компилятор представляет эти не привязанные к типу константы с гораздо боьшей числовой точнотью. чем значения фундаментальных типов, а их арифметика более точная, чем машинная.
```Go
const(
    a = 0xdeadbeef
    b = uint32(deadbeef)
)
```

## Составные типы

**Массивы**
Из-за фиксированной длины массивы редко испльзуются, в основном используются срезы, которые могут увеличиваться и уменьшаться.
```Go
var a [3]int // 3 ячейки с int-ами
var a [3]int = [3]int{1, 2, 3}
var a = [3]int{1,2,3}
var x = [...]int{1,2,3,4,5} // ... - длина определяется по кол-ву литералов
var x = [...]int{1: 1, 10: 2, 2: 3} // - явно указываем индекс ячейки, в которую ввставить значение
x := [...]int{10: 100} // определяет массив со 10 ячейками. 10 элемент равен 100.
```

Если тип массива **сравниваемый**, то можно проверить соответствие каждого элемента массива с каждым другим, через оператор **==**

в Go массивы передаются как копия.
Это можно решить, передавая массив по ссылке


**Срезы**
Срезы - это последовательность данных переменной длины. Все элементы имеют один тип
```Go
var ar []int = array[:3]            // [0;3)
var second_slice []int = array[3:6] // [3;6)
var all_slice = array[:]            // весь массив целиком
```
Срез - это легковесная структура данных, которая предоставляет доступ к последовательности элементов базового массива
Срез состоит из:
- указатель - указывает на первый элемент массива
- длина - **len()** количество элементов среза, она не может превышать емкость 
- емкость - **cap()** максимальное кол-во элементов среза, длина не может быть больше емкости. Емкость постоянно увеличивается, если увеличивается длина.

Несклько срезов могут совместно исопльзовать один и тот же базовый массив и относиться к перекрывающимся частям этого массива.
**Оператор среза** s[i:j] - означает 0 <= i <= j <= cap(s).
То есть создает срез, который состоит из последовательности от i до j (исключительно)

Срезание за пределами cap(array) вызывает аварийную ситуацию.
А срезание за пределами len(array) приводит к расширению среза.

Так как срез содержит указатель на элемент массива, передача среза в функцию позволяет изменять элементы базового массива. То есть копирование среза создает псевдоним для базового массива.

**append** - добавляет элемент в слайс
```Go
array = append(array, 3) // Добавит в array еще один элемент с значением 3
```
**make()** - создает пустой срез
```Go
array := make([]string, 3) // Создаст пустой срез с кол-вом элементов 3
```

**!** Срезы не хранят в себе данных. Когда создается слайс, то создается массив и за нас создается абстракция над массивом, которая позволяет динамически расширять массив.
То есть Срез это всеголишь обертка над массивом.

И поэтому если срез создается из какого-то массива. И в этом массиве или срезе поменять элемент, то он изменится везде.
```Go
	str_arr := [4]int{1, 2, 3, 4}
	
	var a []int = str_arr[:2]
	var b []int = str_arr[2:]
	
	fmt.Println(a)
	fmt.Println(b)
	fmt.Println(str_arr)
	
	fmt.Println("----------------------------")
	
	a[0] = 10            // Изменится везде
	fmt.Println(a)
	fmt.Println(b)
	fmt.Println(str_arr) // 10, 2, 3, 4
```

**MAP структура**

```Go
mapName := map[keyType]valueType
```

Проверка есть ли значение по данному ключу?
```Go
	value, ok := pointsMap["a"]
	if ok {
		fmt.Println(value)
	}
```

**Кодирование и декодирование Map в struct**
Для декодирования Map в struct используется библиотека с github
```Go
import (
	"fmt"
	"github.com/mitchellh/mapstructure"
)

type Point struct {
	X int
	Y int
}

func main() {
	pointsMap := map[string]int{
		"x": 123,
		"y": 345,
	}

	p1 := Point{}
	mapstructure.Decode(pointsMap, &p1)
	fmt.Println(p1) // {123, 345}
}
```

Если имена в структуре и в map не совпадают, то в структуре с помощью тегов можно указать какое имя должен искать декодер

```Go
type Point struct {
	X int `mapstructure:"first"`
	Y int `mapstructure:"second"`
}

func main() {
	p1Map := map[string]int{
		"first" : 123,
		"second" : 456,
	}

	p1 := Point{}
	mapstructure.Decode(p1Map, &p1)
	fmt.Println(p1) // {123, 456}
}
```

## Интерфейсы

Пример интерфейса и его использования
```Go
type User interface {
	Rename(newName string)
	ChangeAge(newAge int)
	String() string
}

var _ fmt.Stringer = &user{} // Явно показывает имплементацию интерфейса Stringer
var _ User = &user{}

type user struct { // Структура, которая имплементирует Stringer
	Name string
	Age  int
}

func (u *user) Rename(newName string) {
	u.Name = newName
}

func (u *user) ChangeAge(newAge int) {
	u.Age = newAge
}

func (u user) String() string { // Имплементация Stringer
	return fmt.Sprintf("%s - %d", u.Name, u.Age)
}

func NewUser(name string, age int) User {
	return &user{
		Name: name,
		Age:  age}
}

func main() {
	u1 := NewUser("V", 12)
	u1.Rename("Valentin")
	u1.ChangeAge(25)
	fmt.Println(u1.String())

	u2 := NewUser("Y", 42)
	fmt.Println(u2.String())
}
```

Для явного указания имплементации интерфейса, можно делать так
```Go
var _ fmt.Stringer = &user{} // Явно показывает имплементацию интерфейса Stringer

type user struct { // Структура, которая имплементирует Stringer
	name string
	age  int
}

func (u user) String() string { // Имплементация Stringer
	return fmt.Sprintf("%s - %d", u.name, u.age)
}
```

## Интерфейс Reader
Интерфейс с одним единственным методом Reader, который позволяет вычитываеть поток данных
в байтах и возвращает число Int и ошибку

Если он вернет ошибку EOF - это End of File, это просто означает, что поток закончился, нечего больше читать.
```Go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

В бесконечном цикле метот Read будет читать, пока файл не закончится.
arr := make([]byte, 4) - Создает пустой срез байт, длиной 4
Далее Reader будет брать по 4 байта и выводить их
таким образом будет
Hell - 4 байта
o wor - еще 4 байта
ld - еще 4 байта
"" - пустой байт, сигнализирующий об окончании файла EOF
```Go
myReader := io.Reader(strings.NewReader("Hello world"))
arr := make([]byte, 4)

for {
	n, err := myReader.Read(arr)
	//fmt.Printf("n = %d err = %v arr = %v\n", n, err, arr)
	fmt.Printf("%q\n", arr[:n])
	if err == io.EOF {
		break
	}
}
```
