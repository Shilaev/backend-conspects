## Структура программы
Программа Go хранится в **одном или нескольких файлах**, с расширением **.go**.
1) Файл начинается с объявления **package** - указывает частью какого пакета является файл.
2) Затем **import** - импортирует другие пакеты
3) Затем последовательность объявления типов, п еременных, констант, функций уровня пакета в произвольном порядке.

```Go
package main
import "fmt"
const someConst = 9.85
func main(){
    var f = someConst
}
```

## Переменные
Объявление **var** создает переменную определенного типа, назначает ей имя и присваивает начальноее значение.
**Полное объявление переменных**
```Go
var varName type = expression // полное указание
var varName = expression // компилятор сам определит тип
var varName type // создаст переменную с нулевым дефолтным
                  //значением (0, false, nil, "")
var i, j, k int // создаст 3 int с нулевым значением
var i, j, k = true, 2.3, "some" // создаст 3 переменные со
                          //значениями, которые указаны далее.
```
**Краткое объявление переменных**
```Go
name := expression
anim := gif.GIF{...}
t := 0.0
x, y := true, 1
```
Краткое объявление переменных может исопльзоваться для вызова функций.
```Go
f, err := os.Open(name)
```
!!Важно. В данном случае err не пересоздастся, а к ней будет присвоено новое значение
```Go
in, err := os.Open()
out, err := os.Create()
```

## Указатели
Переменная представляет собой небольшой блок памяти, содержащий значение.
Значение **указателя** представляет собой **адрес** переменной. Таким образом, **указатель** - это **местоположение в памяти**, где **хранится значение**. Не любое значение имеет адрес, но его имеет любая переменная. С помощью указателя можно считывать или изменять значение переменной косвенно, не используя ее имя, если оно есть.
```Go
var x int
p := &x // указатель на местоположение в памяти, указывает на значение
// p указывает на x
// p содержит адрес x
print(*p) // Это переменная, которую мы найдем, если перейдем по адресу, который хранится внутри p.
```

## Функция new
Еще один способ создания переменных. **new** создает неименованную переменную типа T, инициализирует ее нулевым значением и возвращает ее адрес.
```Go
p := new(int)
```

## Присваивание кортежу поменять местами
Очень удобно менять местами переменные, без добавления временной переменной.
Данная запись
```Go
tmp := x
x = y
y = tmp % y
```
эквивалентна этой, в короткой записи
```Go
x, y = y, x%y
```

## Объявление типов
Объявление type определяет новый именованный тип, который имеет тот же базовый тип, что и существующий.
```Go
type Celsius float64
const AbsoluteZeroC Celsius = -273.15
```

## Пакеты и файлы
Это аналог модулей и библиотек из других языков.
В Go экспортируются идентификаторы. которые начинаются с прописной буквы.
То есть если написать функцию
```Go
func doThis() {
	fmt.Println("doThis")
}
```
То она не будет доступна вне пакета, а если написать
```Go
func DoThis() {
	fmt.Println("doThis")
}

package.DoThis()
```
То вот она будет доступна

## Строки и байтовые срезы
Для работы со строками есть 4 стандартных пакета:
**strings** - предоставляет множество функций для поиска, замены, сравнения. обрезки. разделения, объединения строк
**bytes** - аналогичные функции, но для работы со срезами
**strconv** - функции для преобразования булевых значений, целых чисел и чисел с плавающей точкой в строковое представление и обратно
**unicode** - функции для классификации рун, IsDigit, IsLetter, IsUpper, IsLower и така далее

Строки можно преобразовывать в байтовые срезы и обратно:
```Go
s := "abc"
b := []byte(s)
s2 := string(b)
```
[]byte(s) - выделит память для нового массива байтов, хранящего копию байтов строки s и дает срез, ссылающийся на весь этот массив.

## Преобразования между строками и числами
делается с помощью пакета **strconv***
```Go
strconv.Itoa //integer to ASCII
x := 123
y := strconv.Itoa(x) // 123
```

Для форматирования числе из другой системы счисления
```Go
strconv.FormatInt(int64(x), 2) // 1111011
```

## Константы
Значение констрант известны компилятору и вычисление гарантированно происходит во время компиляции, а не во время выполнения. 
```Go
const name = "value"

const (
    a = 1
    b     // 1 по умолчанию
    c = 2
    d     // 1 по умлочанию
)
```
Многие вычисления констант могут быть полностью завершены во время компиляции, уменьшая тем самым кол-во работы. необходимой во время выполнения. 

**Генератор констант iota**
**iota** - применяется для создания последовательности связанных значений без их явного указания.
в объявлении const значение iota начинается с нуля и увеличивается на единицу для каждого следующего.
```Go
type Counter int

const (
	x Counter = iota // 0
	y                // 1
	z                // 2
	a                // 3
	b                // 4
	g                // 5
)

const (
	_ = 9 + iota
	x                // 10
	y                // 11
	z                // 12
)
```


**Нетипизированные константы**
Константа может быть не привязана к определенному типу.
Компилятор представляет эти не привязанные к типу константы с гораздо боьшей числовой точнотью. чем значения фундаментальных типов, а их арифметика более точная, чем машинная.
```Go
const(
    a = 0xdeadbeef
    b = uint32(deadbeef)
)
```

## Составные типы

**Массивы**
Из-за фиксированной длины массивы редко испльзуются, в основном используются срезы, которые могут увеличиваться и уменьшаться.
```Go
var a [3]int // 3 ячейки с int-ами
var a [3]int = [3]int{1, 2, 3}
var a = [3]int{1,2,3}
var x = [...]int{1,2,3,4,5} // ... - длина определяется по кол-ву литералов
var x = [...]int{1: 1, 10: 2, 2: 3} // - явно указываем индекс ячейки, в которую ввставить значение
x := [...]int{10: 100} // определяет массив со 10 ячейками. 10 элемент равен 100.
```

Если тип массива **сравниваемый**, то можно проверить соответствие каждого элемента массива с каждым другим, через оператор **==**

в Go массивы передаются как копия.
